package com.sb.flake;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;

public abstract class FlakeGenerator implements Serializable {
    protected final Instant EPOCH;
    protected final GenerationRules RULES;

    protected FlakeGenerator(Instant epoch, GenerationRules rules) {
        this.EPOCH = epoch;
        this.RULES = rules;
    }

    public GenerationRules getRules() {
        return RULES;
    }

    public Instant getEpoch() {
        return EPOCH;
    }

    public abstract long nextId();


    /**
     * Parse a flake ID as if it were generated by this generator instance.
     * @param flake the flake id to parse
     * @return the components of that snowflake.
     */
    public FlakeData parse(long flake) {
        long msSinceEpoch = flake >> this.RULES.TIMESTAMP_SHIFT & this.RULES.TIMESTAMP_MASK;
        Instant timestamp = this.EPOCH.plusMillis(msSinceEpoch);
        long workerId = flake >> this.RULES.getWorkerIdShift() & this.RULES.WORKER_ID_MASK;
        long sequenceNumber = flake & this.RULES.SEQUENCE_MASK;
        return new FlakeData(flake, timestamp, Duration.ofMillis(msSinceEpoch), workerId, sequenceNumber);
    }

    /**
     * Isolate the components of the flake as if it were generated by this generator instance.
     * @param flake the flake id to parse
     * @return a long array where [0] is the time difference since the epoch, [1] the workerId, [2] the sequence number.
     */
    public long[] primitiveParse(long flake) {
        return new long[] {
                flake >> this.RULES.TIMESTAMP_SHIFT & this.RULES.TIMESTAMP_MASK,
                flake >> this.RULES.getWorkerIdShift() & this.RULES.WORKER_ID_MASK,
                flake & this.RULES.SEQUENCE_MASK
        };
    }
}
