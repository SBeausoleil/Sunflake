package com.sb.flake;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Classical Twitter Snowflake implementation.
 * This implementation is mostly lockless and uses atomic logic to ensure thread-safety and increase locality of locks.
 * A rare but noticeable (less than 1ms) lock only occurs when the sequence number would be out of bound.
 */
public class SnowflakeGenerator implements Serializable {
    private static final long serialVersionUID = 1L;

    public static final Instant DEFAULT_EPOCH = Instant.parse("2015-01-01T00:00:00Z");

    /**
     * Number of bits in the sequence.
     */
    public static final int SEQUENCE_LENGTH = 12;
    public static final int SEQUENCE_MASK = (1 << SEQUENCE_LENGTH) - 1;
    public static final int MACHINE_ID_LENGTH = 10;
    public static final int MACHINE_ID_SHIFT = SEQUENCE_LENGTH;
    /**
     * Mask on the machine id to ensure correct size.
     * Apply on non-shifted number.
     */
    public static final int MACHINE_ID_MASK = ((1 << (MACHINE_ID_LENGTH)) - 1);
    public static final int TS_LENGTH = 41;
    public static final int TS_SHIFT = SEQUENCE_LENGTH + MACHINE_ID_LENGTH;

    private final Instant EPOCH;

    /**
     * Time since the epoch when this generator was instantiated.
     */
    private final long INSTANCE_START_TIME; // TESTME
    /**
     * To avoid issues with leap seconds and backward flowing time,
     * this generator uses a monotonical clock. Since it is unknown
     * what is the relation of between the epoch of the clock and that
     * of the desired snowflake's epoch, we can produce a timestamp:
     * <p>
     * CLOCK_EPOCH - CURR_TIME + INSTANCE_START_TIME_MS = Timestamp
     */
    private final long CLOCK_EPOCH;
    /**
     * Machine ID shifted 12 bits to the left (BigEndien), ready to stamp (OR operation) on an ID.
     */
    private final int MACHINE_ID;
    /**
     * Previous timestamp already shifted by 41 bits
     */
    private final AtomicLong previousTimestamp;
    private final AtomicInteger sequence;

    public SnowflakeGenerator(int machineId) {
        this(machineId, DEFAULT_EPOCH);
    }

    public SnowflakeGenerator(int machineId, Instant epoch) {
        int maskedId = machineId & MACHINE_ID_MASK;
        if (maskedId != machineId) {
            throw new IllegalArgumentException("Invalid machineId: " + machineId + " (too big). " +
                    "MachineId must be a 12 bits integer.");
        }

        this.EPOCH = epoch;
        INSTANCE_START_TIME = System.currentTimeMillis() - epoch.toEpochMilli();
        MACHINE_ID = maskedId << MACHINE_ID_SHIFT;
        CLOCK_EPOCH = System.nanoTime();
        previousTimestamp = new AtomicLong();
        sequence = new AtomicInteger();
    }

    public short getMachineId() {
        return (short) (MACHINE_ID >> MACHINE_ID_SHIFT);
    }

    public long nextId() {
        long id = shiftedMonotonicTime();
        if (previousTimestamp.getPlain() != id) {
            resetSequence(id);
        }
        int sequenceNumber = getSequenceNumber();
        if (sequenceNumber < sequence.getPlain()) {
            id = awaitNextTimestamp(id);
            sequenceNumber = getSequenceNumber();
        }
        id |= sequenceNumber;
        // Apply worker stamp
        id |= MACHINE_ID;
        // Set the sign bit to 0
        id &= ~(1L << 63);
        return id;
    }

    private int getSequenceNumber() {
        return sequence.getAndIncrement() & SEQUENCE_MASK;
    }

    private synchronized void resetSequence(long newTs) {
        if (newTs > this.previousTimestamp.longValue()) {
            this.previousTimestamp.set(newTs);
            this.sequence.set(0);
        }
    }

    private long shiftedMonotonicTime() {
        //System.out.println();
        long ts = (System.nanoTime() - CLOCK_EPOCH) / 1_000_000;
        //System.out.println("TS: " + ts + " (" + toUnformattedBinary(ts) + ")");
        ts += INSTANCE_START_TIME;
        //System.out.println("Adjusted ts: " + ts + " (" + toUnformattedBinary(ts) + ")");
        ts <<= TS_SHIFT;
        //System.out.println("Shifted (" + TS_SHIFT + ") ts: " + ts + " (" + toUnformattedBinary(ts) + ")");
        //System.out.println(toFormattedBinary(ts));
        return ts;
    }

    private long awaitNextTimestamp(long tsOnArrival) {
        long ts;
        do {
            Thread.onSpinWait(); // Free some CPU resources
            ts = shiftedMonotonicTime();
        } while (ts <= tsOnArrival);
        resetSequence(ts);
        return ts;
    }

    /**
     * Parse a snowflake as if it were generated by this instance.
     * <p>
     * This parse function may be called on a different generator than the one that produced it,
     * however the epoch part will be interpreted as if it came from the parsing generator.
     * The machineId will be correctly parsed from the id.
     * </p>
     *
     * @param snowflake the snowflake id to parse
     * @return the components of that snowflake.
     */
    public FlakeData parse(long snowflake) {
        long msSinceEpoch = snowflake >> TS_SHIFT;
        Instant timestamp = this.EPOCH.plusMillis(msSinceEpoch);
        short machineId = (short) (snowflake >> MACHINE_ID_SHIFT & MACHINE_ID_MASK);
        short sequenceNumber = (short) (snowflake & SEQUENCE_MASK);
        return new FlakeData(snowflake, timestamp, Duration.ofMillis(msSinceEpoch), machineId, sequenceNumber);
    }

    // For JavaFlakeTest
    public long[] primitiveParse(long snowflake) {
        FlakeData data = parse(snowflake);
        return new long[]{
                data.getTimestamp().toEpochMilli(),
                data.getWorkerId(),
                data.getSequenceNumber()
        };
    }

    public static String toUnformattedBinary(long snowflake) {
        StringBuilder sb = new StringBuilder(Long.SIZE);
        for(int i = 0; i < Long.numberOfLeadingZeros(snowflake); i++) {
            sb.append('0');
        }
        sb.append(Long.toBinaryString(snowflake));
        return sb.toString();
    }

    public static String toFormattedBinary(long snowflake) {
        String unformatted = toUnformattedBinary(snowflake);
        StringBuilder sb = new StringBuilder(unformatted.length() + 3); // Add _ for sign separation, _ for ts, _ for machine
        char[] bits = unformatted.toCharArray();
        for (int i = 0; i < unformatted.length(); i++) {
            sb.append(bits[i]);
            if (i == 0) // Sign bit
                sb.append('_');
            else if (i + 1 == 1 + TS_LENGTH) { // TS bits
                sb.append('_');
            } else if (i + 1 == 1 + TS_LENGTH + MACHINE_ID_LENGTH) { // Machine ID bits
                sb.append('_');
            }
        }
        return sb.toString();
    }
}
